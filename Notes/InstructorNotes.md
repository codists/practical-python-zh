# 实用的 Python 编程——讲师说明

作者：戴维·比兹利（David Beazley） 

## 概述

对于如何使用我的课程“实用的 Python 编程”进行教学的问题，本文档提供一些通用的说明和建议，包括课程目标、课程受众、棘手的内容等。

一些人会在一个典型的、为期三天的公司培训中进行教学，本说明就是提供给这些教学人员的。在如何教授自己的课程方面，这些说明可能会给你带来一些启发。

## 目标受众和一般方法

本课程旨在作为已经有一定的编程经验人员的“Python 入门”课程。这绝对不是一门为编程新手而设计的课程。

话虽如此，我发现 Python 课程中的学生也不大可能是硬核软件工程师或者程序员。相反，你可能会遇到工程师，科学家, web 程序员以及经验不足的开发者。学生背景差异很大。有些学生可能具有丰富的 C,C++, Java 经验，有些学生可能了解 PHP 和 HTML，有些学生可能掌握的是诸如 MATLAB 这样的工具，尽管我已经尽了最大努力把课程的先决条件说清楚，但是有些学生可能仍然几乎没有传统的"编程"经验。

考虑到这一点，本课程旨在通过操作数据（尤其是股市数据）的一般问题来教 Python。之所以选择这个领域是因为它很简单，并且无论每个人的背景如何，都应该对此有所了解。举个例子，编程能力很较弱的学生仍然可能要了解一些常用的东西，例如使用电子表格（Excel）。所以，如果他们真的被卡住了，你可以像这样告诉他们“元组的就像电子表格里面的数据行”或者“列表的操作和电子表格的列进行操作并且把结果放到新的一列中类似。”关键思想是扎根于现实世界环境中，而不是偏离到深奥的“计算机科学”问题上（例如：计算斐波那契数列）。

这个领域的问题也可以很好的引入其它编程主题。例如，科学家/工程师可能想了解数据分析或者数据可视化，所以你可以给他们展示如果使用 matplotlib 绘图。Web 程序员可能想要了解如何在网页展示股市数据，所以，你可以讨论模板引擎。系统管理员可能想使用日志文件做一些事情，所以，你可以引导他们查看实时的股票数据流日志文件。软件工程师可能想了解设计，所以，你可以让他们看看将股票数据封装到对象内部或者使程序可扩展的方法（例如，如何让程序以 10 种不同的表格形式产生输出）。你懂的。

## 演示指南

演示幻灯片（notes）为课程提供了叙述结构，供学生练习时参考。加入学生能够阅读那些幻灯片并且他们写代码时有时间回头查看，那么就没必要一字不落的讲解。我倾向于快速地浏览幻灯片，并在前进的过程中展示一些简短的例子。我经常跳过这些幻灯片，进行现场演示。例如，你真的不需要那么多关于列表（list）的幻灯片，而是走向解释器，现场执行一些列表示例即可。经验法则：每张幻灯片的时间不超过 1 分钟，除非是特别棘手的内容。老实说，如果你觉得适合自己的话，可以跳过大部分的幻灯片，而只使用实时演示讲课。我经常这样做。

## 课程练习

本课程大约有 130 个动手练习。如果你进行每一项练习，并让学生有时间思考和写代码，则可能需要大约 10-12 小时。在实践中，你可能会发现学生在某些练习中需要更多的时间。对此，我在下面有一些说明。

你应该向学生反复强调，题解代码是可用的，并且查看和复制题解代码也是可以的——尤其是有时间限制的时候。

在教授课程之前，我强烈建议你浏览并完成每一道练习，以免发生意外。

在授课期间，当学生做练习的时候，我通常也在自己的电脑上从头开始不看答案地完成每一道练习。为此，我强烈建议你手头准备一份练习的打印副本，而不必在电脑上查看练习（电脑屏幕那时可能正在投影）。在练习时间快要结束时，我将会开始讨论我的题解代码，强调屏幕上的不同点并对此进行讨论。如果题解存在任何潜在问题（包括设计注意事项），我也将进行讨论。请向学生强调，在继续之前，他们可能要看看或者复制题解代码。

## 第 1 节:  简介

本节的主要目标是让学生从编程环境开始入手。包括使用交互式shell，编辑或者运行简短的程序。在本节结束时，学生应该能够编写用于读取数据文件并执行简单的计算的简短脚本。他们将会了解数字，字符串，列表和文件，也会了解函数，异常和模块，但是不会介绍得太详细。

本节往往所耗费的时间是最长的，因为学生对工具不熟悉，可能会遇到各种问题。你应该在教室到处走走并且确保每个人可以编辑，运行和调试简单的代码，这是至关重要的。确保学生正确安装了 Python，下载了课程练习，网络正常运行。解决出现的任何其他问题。

时间：我打算在第 1 天的中午结束第 1 节。

## 第 2 节：处理数据

在这门课程中，本节可能是最重要的。它覆盖了数据表示和操作的基础，包括元组，列表，字典和集合。

2.2 节是重中之重，请在合理的情况下，给学生足够的时间让他们完成练习。这些练习可能会持续 45 分钟，具体取决于学生。在本练习的中间，我往往会前进到 2.3 节（格式化输出），给学生足够多的时间来继续做练习。综上所述，2.2 或 2.3 可能需要 1 个小时以上的时间。

2.4 节让学生探索 enumerate() 和 zip() 函数的用法。我认为这两个函数是必不可少的，所以，请不要跳过它们。

2.5 节介绍 collections 模块。关于 collections，大量的内容可以说，但这个时候，学生可能还不完全能领会其重要性。不要停留在“collections 是一个很酷的模块，稍后再看。这仅仅是一些示例”的观点中，而要详细了解collections。

2.6 节介绍列表推导式，这是一个用于处理列表数据的重要特性。向学生强调列表推导式与 SQL 数据库查询非常相似。在练习结束时，我经常做一些涉及更高级内容的交互性示例，如写一个列表推导式，或者使用 matplotlib 将数据可视化。如果你愿意，这也是一个介绍 Jupyter 的机会。

2.7 节是最复杂的练习。它涉及到在 Python 中一级数据的使用，以及事实——诸如列表之类的数据结构可以存储任何类型对象，只要你想。这些练习与解析 CSV 中的数据列相关，稍后在 3.2 节中会再次使用相关的概念。

时间：理想情况下，你希望第一天就完成第 2 节。但是，通常以第 2.5 节或者第 2.6 节结束。因此，如果你觉得自己有写落后，也不要惊慌。

## 第 3 节：程序组织

本节的主要目标是介绍有关函数的更相信的信息，并且鼓励学生使用函数。本节将函数构建到模块和脚本编写中。

3.1 节是关于如何将简单的“脚本”转变为函数。不要鼓励学生写乱七八糟的“脚本”，相反，代码至少应该模块化到函数中。这使代码更易于理解，更易于后续变更，运行更快。函数很好。

在整个课程中，3.2 节可能是最高级的一组练习。本节练习中，学生需要编写一个通用的实用函数来解析面向列的数据。但是，这会大量使用列表推导式和函数（例如，作为一等对象的函数）。你可能需要指导学生完成此代码的每一个步骤，详细地展示它的工作原理。然而，这样做的回报是巨大的——你可以向学生展示一个简短的通用函数，该函数的功能非常强大。如果没有大量复杂的代码，这些功能用C、C++ 或 Java 几乎是不可能写出来的。对于这些代码，有很多可能的设计或者讨论途径。发挥你的想象力吧。

3.3 节为在 3.2 节中创建的函数添加了错误处理。通常，这是一个讨论异常处理的好时机。一定要谈一谈捕获所有异常的危险性。这可能是谈论“Python 之禅”里面“错误绝不能悄悄忽略”原则的好时机。

注意事项：在练习 3.4 之前，确保学生获得了完全可以用的 report.py，pcost.py 和 fileparse.py。如果需要，请从 Solution 目录复制。

3.4 节介绍模块导入。3.2-3.3 节编写的文件用于简化 3.1 节的代码。请注意，你可能需要帮助学生解决 IDLE，sys.path 以及其它与导入有关的各种设置的问题。

3.5 节讨论 `__main__` 和脚本编写。有一点内容是关于命令行参数的。您可能会倾向于讨论类似 argparse 这样的模块。但是请注意，这样做会“打开一个泥潭”(译注：opens up a quagmire，可理解为“引入新的问题”)，一般情况下，最好只提一下然后继续。

3.6 节对 Python 中的设计展开讨论。编写灵活的代码好还是编写硬编码文件名的代码好？这是你修改代码并必须对已有代码进行重构的第一个地方。

从这里开始，大部分的练习都是对已经写好的代码做一些小改动。

## 第 4 节：类和对象

本节是关于面向对象编程（OOP）的。一般来说，假定学生在面向对象（OO）方面有深厚的背景是不保险的。因此，在开始之前，我通常会对面向对象编程“风格”以及数据和方法是如何绑定在一起的进行描述。以字符串和列表为例，说明什么是“对象”以及对象是如何调用（通过 . 号调用）方法进行操作的。强调方法是如何绑定到对象本身的。例如，使用 items.append(x) ，而不是调用一个单独的函数 append(items, x)。

4.1 节介绍类语句以及向学生展示如何创建一个基本的对象。实际上，这只是为了介绍：类可以作为定义简单数据结构的一种方式——可以和第 2 节中为此目的而使用元组和列表联系起来。

4.2 节是关于继承以及如何使用使用继承创建可扩展程序的。就面向对象编程和面向对象设计而言，本组练习可能是最重要的。请给学生足够的时间（30-45 分钟）学习继承。根据兴趣，你可以花费大量时间对面向对象编程的不同方面进行讨论。例如，不同的设计模式，继承层次结构，抽象基类等。

4.3 节使用特殊方法做了一些试验。我不会花费太多时间去折腾特殊方法。稍后，练习 6.1 和其它地方会介绍特殊方法。

时间上，通常是第二天结束。

## 第 5 节：内部对象

本节将向学生介绍对象系统的幕后知识，如何使用字典构建对象系统，实例和类是如何绑定在一起的，继承是如何工作的。不过，本节最重要的部分可能是封装（private，attributes,，properties，slots等）。

5.1 节揭开表面现象，让学生观察和使用实例和类的底层字典。

5.2 节讨论在 get/set 函数背后隐藏属性（attribute）并使用特征属性（properties）。我通常强调，这些技术在库和框架中很常用——尤其是需要对用户的选择进行控制的时候。

精通 Python 的高手会发现我根本没有讨论像描述器（descriptors）或属性访问方法（`__getattr__`，
`__setattr__`）这样的高级主题。根据以往的经验，我发现，这样做对于参加入门课程的学生而言，精神负担太重了。此时，每个人的头脑已经处于爆炸的边缘，如果现在去讨论描述器的工作原理，那么，要么在今天余下的时间里，要么在这门课程剩下的时间里，你会失去他们。将这些高级主题放到“高级 Python”课程吧。

如果你正在看着时钟想着“我讲不完这门课程了”，那么你完全可以跳过第 5 节。

## 第 6 节：生成器

本节的主要目的是介绍生成器，生成器可用于实现自定义迭代。并将其用于与数据处理相关的各种问题。本节练习让学生学会分析流数据。练习使用被写入日志文件的股票更新信息作为流数据。

在本节中，有两大观点需要强调一下。第一个观点，可以使用生成器编写基于增量处理（incremental processing）的代码。这对于流数据或其它庞大的数据集非常有用，因为这些数据太大了，无法一次性全部放入内存中。第二个观点，你可以将生成器/迭代器链接在一起使用以创建处理管道（类似于 Unix 的 pipes）。同样，这是处理和思考流数据，大型数据集的非常强大的方法。

省略的内容：尽管本节描述了迭代协议，但是并没有详细介绍如何创建可迭代对象（即带有 `__iter__()` 和 `next()` 方法的类）。在实践中，我发现没必要总是介绍如何创建可迭代对象（生成器通常更好/更简单）。所以，为了节省时间，我特意将其省略。也不包括扩展生成器（协程）和并发生成器（如微线程 tasklets）。在高级课程中，最好包含这些内容。

## 第 7 节：高级主题

本节基本上是各种高级主题。这些主题本可以在之前进行介绍，但是由于与课程流程和课程练习内容相关的各种原因而没有介绍。如果你一定要知道的话，我曾经在课程的前面介绍过这些内容。因为学生已经被充足的信息所困扰，所以稍后再讨论这些高级主题更好一些——特别是到目前为止，每个人对 Python 都更加熟悉并且开始掌握使用 Python 的窍门。

高级主题包括可变参数（(*args, **kwargs），匿名函数（lambda），闭包（closures）以及装饰器（decorators）。对装饰器的讨论只是元编程（metaprogramming）的一小部分。对此，你可以畅所欲言，但是我可能会避开元类（metaclasses）。最近，我一直在演示“numba”，将其作为更有趣的装饰器的例子。

如果时间紧迫，第 7 节的大部分内容可以跳过或者高度浓缩（例如跳过练习）。

## 第 8 节：测试和调试

本节主要目的是介绍各种与测试、调试、以及软件开发相关的工具和技术。向学生介绍单元测试模块（unittest）、日志模块（logging），讨论断言（assertions）和"契约（contract）编程的思想"，展示调试器（debugger）和分析器（profiler）。这其中的大部分内容是不言自明的。

## 第 9 节：包

现在，学生已经编写了各种文件（pcost.py，report.py，fileparse.py，tableformat.py，stock.py，portfolio.py，follow.py......）。本节主要有两个目标：第一个，将所有的代码放入 Python 包结构中，虽然这只是简单的介绍，但是它们会将文件移到一个目录中，并且所有的内容将会被破坏，所以需要对导入语句（与包相关的导入）进行修改，并且可能需要弄一个 `__init__.py` 文件。第二个，编写一个简单的 setup.py 文件用于打包代码并分发给其他人。就这些，本课程到此结束。

[目录](Contents.md)


